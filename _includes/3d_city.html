<script type="module">
  const loadStart = Date.now();

  import * as THREE from "three";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  const ASPECT_RATIO = 27 / 7;
  const FRUSTUM_SIZE = 5;
  const NEAR_CLIP = -5;
  const FAR_CLIP = 40;

  const INITIAL_CAMERA_POSITION = [20, 0, 0];
  const DRAG_ROTATION_SPEED = 0.1;
  const AUTO_ROTATION_SPEED = 0.21;
  const MAX_FRAME_TIME_SECONDS = 0.1;

  const BACKGROUND_COLOR = 0x000000;

  const LIGHT_SIZE = 5;
  const LIGHT_INTENSITY = 200;
  const LIGHT_OFFSET = [50, 0, 0];
  let targetRotation = document.documentElement.classList.contains("dark-mode")
    ? 0
    : Math.PI;

  const MIN_LOAD_DURATION_FOR_FADE = 200; // ms;

  const MODEL_GLB_PATH = "/assets/city.glb";
  const INITIAL_MODEL_ROTATION = 0.5;

  const container = document.querySelector("header .wrapper");

  const ASPECT = 10 / 3;

  const canvasWidth = Math.min(520, window.screen.width);
  const canvasHeight = canvasWidth / ASPECT;

  const clock = new THREE.Clock();

  // Create a renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(canvasWidth, canvasHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x000000, 0);
  container.appendChild(renderer.domElement);
  renderer.domElement.style.display = "none";

  // Create a scene
  const scene = new THREE.Scene();
  // scene.background = new THREE.Color(BACKGROUND_COLOR);

  // Set up the camera (Orthographic)
  const camera = new THREE.OrthographicCamera(
    -FRUSTUM_SIZE * ASPECT_RATIO,
    FRUSTUM_SIZE * ASPECT_RATIO,
    FRUSTUM_SIZE,
    -FRUSTUM_SIZE,
    NEAR_CLIP,
    FAR_CLIP
  );

  const position =
    window.localStorage.cameraStart?.split(",") ?? INITIAL_CAMERA_POSITION;

  camera.position.set(...position);
  scene.add(camera);

  // Orbit controls
  const controls = new OrbitControls(camera, renderer.domElement);

  controls.minPolarAngle = Math.PI / 2;
  controls.maxPolarAngle = Math.PI / 2;
  controls.enableZoom = false;
  controls.enablePan = false;
  controls.enableDamping = true;
  controls.rotateSpeed = DRAG_ROTATION_SPEED;
  controls.autoRotate = true;
  controls.autoRotateSpeed = AUTO_ROTATION_SPEED;
  controls.update();

  // Add some lighting
  const rectLight = new THREE.RectAreaLight(
    0xffffff,
    LIGHT_INTENSITY,
    LIGHT_SIZE,
    LIGHT_SIZE
  );
  rectLight.position.set(...LIGHT_OFFSET);
  rectLight.lookAt(0, 0, 0);

  const lightHandle = new THREE.Object3D();
  lightHandle.add(rectLight);
  lightHandle.rotation.y = targetRotation;
  lightHandle.rotation.x = Math.PI / 3;
  camera.add(lightHandle);

  // Load a GLB model
  let model = null;

  const loader = new GLTFLoader();
  loader.load(
    MODEL_GLB_PATH,
    (gltf) => {
      model = gltf.scene;
      model.rotateY(INITIAL_MODEL_ROTATION);
      model.traverse((child) => {
        if (child.material) {
          child.material.metalness = 0;
        }
      });

      scene.add(model);

      const loadTime = Date.now() - loadStart;
      if (loadTime > MIN_LOAD_DURATION_FOR_FADE) {
        renderer.domElement.classList.add("fade-in");
      }

      // Remove loading highlights
      renderer.domElement.style.display = "block";
      container.querySelector(".loader").classList.remove("pulse-background");

      render();
    },
    undefined,
    (error) => {
      console.error("Error loading the model", error);
    }
  );

  const render = () => {
    requestAnimationFrame(render);

    let deltaTime = clock.getDelta();
    deltaTime = Math.min(MAX_FRAME_TIME_SECONDS, deltaTime);

    lightHandle.rotation.y = THREE.MathUtils.lerp(
      lightHandle.rotation.y,
      targetRotation,
      deltaTime
    );

    controls.update(deltaTime);
    window.localStorage.cameraStart = camera.position.toArray();

    renderer.render(scene, camera);
  };

  window.flipLights = () => {
    targetRotation = targetRotation > 0 ? 0 : Math.PI;
  };
</script>
